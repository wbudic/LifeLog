.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DBD::SQLite2 3pm"
.TH DBD::SQLite2 3pm "2004-09-10" "perl v5.22.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBD::SQLite2 \- Self Contained RDBMS in a DBI Driver (sqlite 2.x)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use DBI;
\&  my $dbh = DBI\->connect("dbi:SQLite2:dbname=dbfile","","");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
SQLite is a public domain \s-1RDBMS\s0 database engine that you can find
at http://www.hwaci.com/sw/sqlite/.
.PP
Rather than ask you to install SQLite first, because SQLite is public
domain, DBD::SQLite2 includes the entire thing in the distribution. So
in order to get a fast transaction capable \s-1RDBMS\s0 working for your
perl project you simply have to install this module, and \fBnothing\fR
else.
.PP
SQLite supports the following features:
.IP "Implements a large subset of \s-1SQL92\s0" 4
.IX Item "Implements a large subset of SQL92"
See http://www.hwaci.com/sw/sqlite/lang.html for details.
.IP "A complete \s-1DB\s0 in a single disk file" 4
.IX Item "A complete DB in a single disk file"
Everything for your database is stored in a single disk file, making it
easier to move things around than with \s-1DBD::CSV.\s0
.IP "Atomic commit and rollback" 4
.IX Item "Atomic commit and rollback"
Yes, DBD::SQLite2 is small and light, but it supports full transactions!
.IP "Extensible" 4
.IX Item "Extensible"
User-defined aggregate or regular functions can be registered with the
\&\s-1SQL\s0 parser.
.PP
There's lots more to it, so please refer to the docs on the SQLite web
page, listed above, for \s-1SQL\s0 details. Also refer to \s-1DBI\s0 for details
on how to use \s-1DBI\s0 itself.
.SH "CONFORMANCE WITH DBI SPECIFICATION"
.IX Header "CONFORMANCE WITH DBI SPECIFICATION"
The \s-1API\s0 works like every \s-1DBI\s0 module does. Please see \s-1DBI\s0 for more
details about core features.
.PP
Currently many statement attributes are not implemented or are
limited by the typeless nature of the SQLite database.
.SH "DRIVER PRIVATE ATTRIBUTES"
.IX Header "DRIVER PRIVATE ATTRIBUTES"
.SS "Database Handle Attributes"
.IX Subsection "Database Handle Attributes"
.IP "sqlite_version" 4
.IX Item "sqlite_version"
Returns the version of the SQLite library which DBD::SQLite2 is using, e.g., \*(L"2.8.0\*(R".
.IP "sqlite_encoding" 4
.IX Item "sqlite_encoding"
Returns either \*(L"\s-1UTF\-8\*(R"\s0 or \*(L"iso8859\*(R" to indicate how the SQLite library was compiled.
.IP "sqlite_handle_binary_nulls" 4
.IX Item "sqlite_handle_binary_nulls"
Set this attribute to 1 to transparently handle binary nulls in quoted
and returned data.
.Sp
\&\fB\s-1NOTE:\s0\fR This will cause all backslash characters (\f(CW\*(C`\e\*(C'\fR) to be doubled
up in all columns regardless of whether or not they contain binary
data or not. This may break your database if you use it from another
application. This does not use the built in sqlite_encode_binary
and sqlite_decode_binary functions, which may be considered a bug.
.SH "DRIVER PRIVATE METHODS"
.IX Header "DRIVER PRIVATE METHODS"
.ie n .SS "$dbh\->func('last_insert_rowid')"
.el .SS "\f(CW$dbh\fP\->func('last_insert_rowid')"
.IX Subsection "$dbh->func('last_insert_rowid')"
This method returns the last inserted rowid. If you specify an \s-1INTEGER PRIMARY
KEY\s0 as the first column in your table, that is the column that is returned.
Otherwise, it is the hidden \s-1ROWID\s0 column. See the sqlite docs for details.
.ie n .SS "$dbh\->func( $name, $argc, $func_ref, ""create_function"" )"
.el .SS "\f(CW$dbh\fP\->func( \f(CW$name\fP, \f(CW$argc\fP, \f(CW$func_ref\fP, ``create_function'' )"
.IX Subsection "$dbh->func( $name, $argc, $func_ref, create_function )"
This method will register a new function which will be useable in \s-1SQL\s0
query. The method's parameters are:
.ie n .IP "$name" 4
.el .IP "\f(CW$name\fR" 4
.IX Item "$name"
The name of the function. This is the name of the function as it will
be used from \s-1SQL.\s0
.ie n .IP "$argc" 4
.el .IP "\f(CW$argc\fR" 4
.IX Item "$argc"
The number of arguments taken by the function. If this number is \-1,
the function can take any number of arguments.
.ie n .IP "$func_ref" 4
.el .IP "\f(CW$func_ref\fR" 4
.IX Item "$func_ref"
This should be a reference to the function's implementation.
.PP
For example, here is how to define a \fInow()\fR function which returns the
current number of seconds since the epoch:
.PP
.Vb 1
\&    $dbh\->func( \*(Aqnow\*(Aq, 0, sub { return time }, \*(Aqcreate_function\*(Aq );
.Ve
.PP
After this, it could be use from \s-1SQL\s0 as:
.PP
.Vb 1
\&    INSERT INTO mytable ( now() );
.Ve
.ie n .SS "$dbh\->func( $name, $argc, $pkg, 'create_aggregate' )"
.el .SS "\f(CW$dbh\fP\->func( \f(CW$name\fP, \f(CW$argc\fP, \f(CW$pkg\fP, 'create_aggregate' )"
.IX Subsection "$dbh->func( $name, $argc, $pkg, 'create_aggregate' )"
This method will register a new aggregate function which can then used
from \s-1SQL.\s0 The method's parameters are:
.ie n .IP "$name" 4
.el .IP "\f(CW$name\fR" 4
.IX Item "$name"
The name of the aggregate function, this is the name under which the
function will be available from \s-1SQL.\s0
.ie n .IP "$argc" 4
.el .IP "\f(CW$argc\fR" 4
.IX Item "$argc"
This is an integer which tells the \s-1SQL\s0 parser how many arguments the
function takes. If that number is \-1, the function can take any number
of arguments.
.ie n .IP "$pkg" 4
.el .IP "\f(CW$pkg\fR" 4
.IX Item "$pkg"
This is the package which implements the aggregator interface.
.PP
The aggregator interface consists of defining three methods:
.IP "\fInew()\fR" 4
.IX Item "new()"
This method will be called once to create an object which should
be used to aggregate the rows in a particular group. The \fIstep()\fR and
\&\fIfinalize()\fR methods will be called upon the reference return by
the method.
.IP "step(@_)" 4
.IX Item "step(@_)"
This method will be called once for each rows in the aggregate.
.IP "\fIfinalize()\fR" 4
.IX Item "finalize()"
This method will be called once all rows in the aggregate were
processed and it should return the aggregate function's result. When
there is no rows in the aggregate, \fIfinalize()\fR will be called right
after \fInew()\fR.
.PP
Here is a simple aggregate function which returns the variance
(example adapted from pysqlite):
.PP
.Vb 1
\&    package variance;
\&
\&    sub new { bless [], shift; }
\&
\&    sub step {
\&        my ( $self, $value ) = @_;
\&
\&        push @$self, $value;
\&    }
\&
\&    sub finalize {
\&        my $self = $_[0];
\&
\&        my $n = @$self;
\&
\&        # Variance is NULL unless there is more than one row
\&        return undef unless $n || $n == 1;
\&
\&        my $mu = 0;
\&        foreach my $v ( @$self ) {
\&            $mu += $v;
\&        }
\&        $mu /= $n;
\&
\&        my $sigma = 0;
\&        foreach my $v ( @$self ) {
\&            $sigma += ($x \- $mu)**2;
\&        }
\&        $sigma = $sigma / ($n \- 1);
\&
\&        return $sigma;
\&    }
\&
\&    $dbh\->func( "variance", 1, \*(Aqvariance\*(Aq, "create_aggregate" );
.Ve
.PP
The aggregate function can then be used as:
.PP
.Vb 2
\&    SELECT group_name, variance(score) FROM results
\&    GROUP BY group_name;
.Ve
.SH "NOTES"
.IX Header "NOTES"
To access the database from the command line, try using dbish which comes with
the \s-1DBI\s0 module. Just type:
.PP
.Vb 1
\&  dbish dbi:SQLite:foo.db
.Ve
.PP
On the command line to access the file \fIfoo.db\fR.
.PP
Alternatively you can install SQLite from the link above without conflicting
with DBD::SQLite2 and use the supplied \f(CW\*(C`sqlite\*(C'\fR command line tool.
.SH "PERFORMANCE"
.IX Header "PERFORMANCE"
SQLite is fast, very fast. I recently processed my 72MB log file with it,
inserting the data (400,000+ rows) by using transactions and only committing
every 1000 rows (otherwise the insertion is quite slow), and then performing
queries on the data.
.PP
Queries like count(*) and avg(bytes) took fractions of a second to return,
but what surprised me most of all was:
.PP
.Vb 4
\&  SELECT url, count(*) as count FROM access_log
\&    GROUP BY url
\&    ORDER BY count desc
\&    LIMIT 20
.Ve
.PP
To discover the top 20 hit URLs on the site (http://axkit.org), and it
returned within 2 seconds. I'm seriously considering switching my log
analysis code to use this little speed demon!
.PP
Oh yeah, and that was with no indexes on the table, on a 400MHz \s-1PIII.\s0
.PP
For best performance be sure to tune your hdparm settings if you are
using linux. Also you might want to set:
.PP
.Vb 1
\&  PRAGMA default_synchronous = OFF
.Ve
.PP
Which will prevent sqlite from doing fsync's when writing (which
slows down non-transactional writes significantly) at the expense of some
peace of mind. Also try playing with the cache_size pragma.
.SH "BUGS"
.IX Header "BUGS"
Likely to be many, please use http://rt.cpan.org/ for reporting bugs.
.SH "AUTHOR"
.IX Header "AUTHOR"
Matt Sergeant, matt@sergeant.org
.PP
Perl extension functions contributed by Francis J. Lacoste
<flacoste@logreport.org> and Wolfgang Sourdeau
<wolfgang@logreport.org>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1DBI\s0.
